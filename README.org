# -*- no-klobber-test: "I should still be here after it is all over!"; org-adapt-indentation: nil; org-edit-src-content-indentation: 0; orgstrap-cypher: sha256; orgstrap-block-checksum: 595964ff8394ab1ea6282a13e76b3f4d757f358a337b4cb4c52df0b2266c9fd3; -*-
# [[orgstrap][jump to orgstrap block for this file]]
#+title: Bootstrap an org-mode file using file local variables
#+options: num:nil \n:nil
#+LATEX_HEADER: \usepackage[margin=0.8in]{geometry}
#+LATEX_HEADER: \setlength\parindent{0pt}

# [[file:./orgstrap.pdf]]
# [[file:./orgstrap.html]]

=orgstrap= is a specification and tools for standalone self-bootstrapping =org-mode= files.

This file bootstraps itself to provide the functionality needed to use
=orgstrap= in any =org-mode= file.

=orgstrap= works with all versions of emacs since =24.4= and all versions of org since =8.2.10=.

* Getting started
Using =orgstrap= is easy.

1. Obtain the org mode source for this file. (e.g.
   [[https://raw.githubusercontent.com/tgbugs/orgstrap/master/orgstrap.org][from GitHub]]).
2. Open the source in emacs[fn::This is usually the most difficult step. See
   [[file:::#future-work][Future work]] for ideas about how to get from zero to emacs.]
   (e.g. =M-x= =url-handler-mode= then =C-x C-f= @@latex: \\@@
   =https://raw.githubusercontent.com/tgbugs/orgstrap/master/orgstrap.org=).
3. Decline the file local variables.
4. Inspect the [[orgstrap][orgstrap block]] and file local variables.
5. Reload the file and accept the file local variables.

Congratulations you can now use =orgstrap= with your own files!

Use =M-x= =orgstrap-init= to add the basic =orgstrap=
machinery to the file in the current buffer.

A minor mode for editing orgstrapped files is included as =orgstrap-mode=.
It is also activated by =orgstrap-init= and when enabled it automatically
updates the =orgstrap-block-checksum= local variable whenever the =orgstrap=
block changes.

If you do not use =orgstrap-mode= then the easiest way to add the orgstrap
checksum to a file is to invoke =M-x= =orgstrap-add-block-checksum=.

# SOON TM
If you would prefer a slightly more sane installation experience that doesn't
vanish until you reopen this file every time you restart emacs, orgstrap is
available on melpa.

The rest of this file is an overview of the use cases for =orgstrap= and
the implementation of =orgstrap= along with discussion and commentary.

If you are looking for examples of how to use =orgstrap= this files is a good place to start.
* Hello =orgstrap=
The bare minimum needed to make an =org-mode= file executable (with a bit of safety).
#+caption: [[file:./orgstrap-minimal.org]]
#+begin_src org :tangle ./orgstrap-minimal.org
# -*- orgstrap-cypher: sha256; orgstrap-block-checksum: 66ba9b040e22cc1d30b6f1d428b2641758ce1e5f6ff9ac8afd32ce7d2f4a1bae; -*-
# [[orgstrap][jump to orgstrap block for this file]]

,#+name: orgstrap
,#+begin_src elisp :results none :noweb yes
(message "orgstrap successful!")
,#+end_src

=orgstrap= a plain-text executable format.

# Local Variables:
# orgstrap-local-variables-block-version: "0.2"
# eval: (defun orgstrap--confirm-eval (lang body) (not (and (member lang '("elisp" "emacs-lisp")) (eq orgstrap-block-checksum (intern (secure-hash orgstrap-cypher (let ((print-quoted nil)) (prin1-to-string (read (concat "(progn\n" body "\n)"))))))))))
# eval: (setq-local org-confirm-babel-evaluate #'orgstrap--confirm-eval)
# eval: (unwind-protect (save-excursion (org-babel-goto-named-src-block "orgstrap") (org-babel-execute-src-block)) (setq-local org-confirm-babel-evaluate t) (fmakunbound #'orgstrap--confirm-eval))
# End:
#+end_src
* Inspiration
By default =org-mode= source block headers only take existing elisp functions as arguments.

This means that header arguments can become extremely verbose.

Wouldn't it be great if you could use the magical mystical power of =defun=
inside an org file itself to provide simple, reusable functionality rather
than +copying and pasting+ +yanking and putting+ killing and yanking raw
elisp around the buffer?

With =orgstrap= you can.

=orgstrap= makes sure that the functionality that you need is available when you need it.
Whether it is =(defun dir-tramp-sudo (host) (format "/ssh:%s|sudo:%s:" host host))= to
simplify a pattern for remote execution when using the =:dir= header argument, or a
function to detect and set the right environment variables, =orgstrap= is there for you.
* Use cases
=orgstrap= essentially specifies a plain-text executable file format.
Thus, in principle it can be used for literally anything.

While I personally find this to be totally radically awesome, there are much
better, saner, and safer ways to execute arbitrary code than to hash some elisp
source blocks and use emacs file local variables to automatically eval a specially
named[fn::Since all the conventions for how this is done are defined locally by each
file you can rename the special block however you see fit, perhaps from =orgstrap= to
=main= if you need to pretend that the file is actually c source code with some special syntax.]
source block only when it matches the hash.

#+caption: Things you can do with arbitrary code execution.
#+name: table-use-cases
|----------------------------------------+------------+--------------------------------|
| Use case                               | Good idea  | Alternative                    |
|----------------------------------------+------------+--------------------------------|
| Always run defuns used in file         | Yes        | init.el, =C-c C-c=             |
| Install elisp code directly            | No         | Use =packages.el=              |
| Self tangling files                    | I do it    | =C-c C-v C-t=                  |
| Install packages required by file      | Probably   | System package manager         |
| Create an emacs based botnet           | Definitely | ???                            |
| Replace hard to follow instructions    | Yes        | Hard to follow instructions    |
| Tangle git hook files for publishing   | Yes        | Manually tangle                |
| System specific behavior without edits | Yes        | #+name: literal blocks via =:= |
| Version control for source blocks      | Please no  | git, hg, svn, anything please  |
| Detect and set environment variables   | Yes        |                                |
|----------------------------------------+------------+--------------------------------|
# Actually I'm kind of hyped for though of describing the system used to version
# control the code in the file itself. Not so simple to pull off though.
# It only sort of works in this case because we have the rest of the file under
# version control in another system.
* Details
The first emacs lisp source block named =orgstrap= in an org file is
automatically run using an =exec:= file local variable. Users can
review and add the file local variables to their known safe list
so that the code can be run in the future without the need to bother
them again.

When opening a file for the first time, users should decline the local
variables, review the =orgstrap= block directly, and then reload revisit,
or =M-x= =org-mode= and only then accept the local variables.

This is the =orgstrap= block that is used for this file.

#+caption: The =orgstrap= block that is used for this file.
#+name: orgstrap
#+begin_src elisp :results none :noweb no-export
;; This is an example that also nowebs in the source for
;; `orgstrap-init' and `orgstrap-add-block-checksum' along
;; with the rest of the orgstrap machinery so it is easy to
;; use orgstrap to create and update orgstrap blocks

<<orgstrap-edit-helper-defuns>>
<<orgstrap-init-helper-defuns>>
<<orgstrap-install-helper-defuns>>
<<orgstrap-extra-helper-defuns>>

;; helper functions to update examples
(defun orgstrap--update-examples ()
  "Use with `orgstrap-on-change-hook' to automatically keep the contents
of the example blocks in sync."
  (let ((pairs `(("local-variables-prop-line-example" ,(orgstrap--local-variables-prop-line-string))
                 ("local-variables-example" ,(orgstrap--file-local-variables-string)))))
    (mapcar (lambda (name-content) (apply #'orgstrap-update-src-block name-content)) pairs)))

(defun orgstrap--local-variables-prop-line-string ()
  "Copy the first logical line of the file since it is easier and faster
than trying to sort out which variables were or were not in the prop line."
;; XXX NOTE There are some cases involving bootstrapping to emacs where the first line of
;;an org-mode file is a shebang, but we will deal with those if and when they arrise
  (buffer-substring-no-properties 1 (save-excursion (goto-char 0) (next-logical-line) (point))))

(defun orgstrap--file-local-variables-string ()
  (with-temp-buffer
    (org-mode)
    (orgstrap--add-file-local-variables)
    (buffer-string)))

;; tangle blocks and update examples on change
(add-hook 'orgstrap-on-change-hook #'org-babel-tangle)
(add-hook 'orgstrap-on-change-hook #'orgstrap--update-examples)
;; enable orgstrap mode locally for this file when this block runs
(orgstrap-mode)

(message "orgstrap complete!")
#+end_src

The headers for the block above look like this.
#+name: orgstrap-example
#+begin_example org :eval never :noweb no
,#+name: orgstrap
,#+begin_src elisp :results none :noweb no-export
<<orgstrap>>
,#+end_src
#+end_example

Additional machinery is provided as part of this file to update the local
variable value of =orgstrap-block-checksum= so that only known blocks can
be run. Note that this DOES NOT PROTECT against someone changing the block
and the checksum at the same time and sending you a malicious file! You need
an alternate and trusted source against which to verify the checksum of the
=orgstrap= block.
** Portability
A couple of notes on portability and backward compatibility with older
versions of emacs. I have tried to get =orgstrap= running on emacs-23,
however the differences between org =6.33x= and org =8.2.10= are too
large to be overcome without significant additional code. First, all
uses of =(setq-local var "value")= have to be changed to
=(set (make-local-variable 'var) "value")= so that the local variable
eval code can run. However once that is done, you discover that all of
the org-babel functions are missing. Therefore, we don't support emacs-23
and older versions.
* Local Variables
** Overview
Local variables must go at the end of a file.

We have to use =setq-local= on =org-confirm-babel-evaluate= because it is marked
as a =safe-local-variable=.  In this context this workaround seems reasonable and
not malicious because the use of =eval:= should alert users that some arbitrary
stuff is going on and that they should be on high alert to check it.

Below in [[#local-variable-definitions][Definitions]] there is a more readable
version of what the compacted local variables code at the end of the file is doing.
*Make sure to check that the code matches when reviewing local variables.*
# TODO it is entirely possible to automate that check
# but not without already having orgstrap available.
** Normalization
#+name: orgstrap-code-normalization
#+begin_src elisp :eval never
(let ((print-quoted nil))
  (prin1-to-string (read (concat "(progn\n" body "\n)"))))
#+end_src

=prin1-to-string= is used to normalize the code in the orgstrap block,
removing any comments and formatting irregularities. This is important
for two reasons.

First it helps prevent denial of service attacks against human auditors
who have low bandwidth for detecting fiddly changes.

Second, normalization that ignores comments makes it possible to improve
the documentation of code without changing the checksum. Hopefully this
will reduce one of the obstacles to enhancing the documentation of orgstrap
code and blocks over time since rehashing will not be required when the
meaningful code itself has not changed.

=(print-quoted nil)= is needed for backward compatibility due to a change
to the default from =nil= to =t= in emacs-27 (sigh). See
[[orgit-rev:~/git/NOFORK/emacs::72ee93d68daea00e2ee69417afd4e31b3145a9fa][emacs commit 72ee93d68daea00e2ee69417afd4e31b3145a9fa]].

#+caption: XXX portability note
#+begin_verse
For emacs < 26 (org < 9) either lowercase =#+caption:= must be placed _BEFORE_ =#+name:=
OR =#+CAPTION:= must be uppercase and can come after =#+name:=,
otherwise =#+name:= will not be associated with the block.
What a fun bug.

Addendum. Apparently in the older version of org =:noweb= is always yes.
Therefore if you forget to set =:noweb= on a block, testing against emacs
24 or 25 will alert you to this.
#+end_verse

#+caption: rename to orgstrap-code-normalization to use this block for debug
#+name: orgstrap-code-normalization-debug
#+begin_src elisp :eval never :exports none
(let* ((print-quoted nil)
       (bname (format "body-norm-%s" emacs-major-version))
       (buffer (let ((existing (get-buffer bname)))
                 (if existing existing
                   (create-file-buffer bname))))
       (body-normalized (prin1-to-string (read (concat "(progn\n" body "\n)")))))
  (with-current-buffer buffer
    (erase-buffer)
    (insert body-normalized))
  body-normalized)
#+end_src
** Definitions
:PROPERTIES:
:CUSTOM_ID:  local-variable-definitions
:END:
These blocks are nowebbed into ref:orgstrap-init-helper-defuns and are
used directly by =orgstrap-init= to populate file local variables.

#+caption: local variables version 0.1 (portable)
#+name: orgstrap-file-local-variables-0.1
#+begin_src elisp :eval never :noweb yes
<<orgstrap-expand-body>>

(defun orgstrap--confirm-eval (lang body)
  ;; `org-confirm-babel-evaluate' will prompt the user when the value
  ;; that is returned is non-nil, therefore we negate positive matchs
  (not (and (member lang '("elisp" "emacs-lisp"))
            (let* ((body (orgstrap--expand-body (org-babel-get-src-block-info)))
                   (body-normalized
                    <<orgstrap-code-normalization>>)
                   (content-checksum
                    (intern
                     (secure-hash
                      orgstrap-cypher
                      body-normalized))))
              ;;(message "%s %s" orgstrap-block-checksum content-checksum)
              ;;(message "%s" body-normalized)
              (eq orgstrap-block-checksum content-checksum)))))

<<orgstrap-file-local-variables-shared>>
#+end_src

#+caption: local variables version 0.2 (portable if not using noweb)
#+name: orgstrap-file-local-variables-0.2
#+begin_src elisp :eval never :noweb yes
(defun orgstrap--confirm-eval (lang body)
  (not (and (member lang '("elisp" "emacs-lisp"))
            (eq orgstrap-block-checksum
                (intern
                 (secure-hash
                  orgstrap-cypher
                  <<orgstrap-code-normalization>>))))))

<<orgstrap-file-local-variables-shared>>
#+end_src

Once =orgstrap-confirm-eval= is defined the rest of the =eval:= local variables are the same.
#+caption: common local variables
#+name: orgstrap-file-local-variables-shared
#+begin_src elisp :eval never
(setq-local org-confirm-babel-evaluate #'orgstrap--confirm-eval)

(unwind-protect
    (save-excursion
      (org-babel-goto-named-src-block "orgstrap")
      (org-babel-execute-src-block))
  (setq-local org-confirm-babel-evaluate t)
  (fmakunbound #'orgstrap--confirm-eval))
#+end_src
** Note on noweb support
The minimal set of local variables (=0.2=) only works if you don't use noweb or if your
copy of =org-mode= has the fix for =org-babel-check-confirm-evaluate= applied from
https://code.orgmode.org/bzg/org-mode/commit/df5a83637518ad9aa586d49884a6271f11afc592.
# orgit-rev:~/git/NOFORK/org-mode::df5a83637518ad9aa586d49884a6271f11afc592
The fix is available in org version =9.3.7-22=. Note that coderefs must be
in comments to get consistent hashing when using this patch.

Version =0.1= of the =orgstrap= local variables described below is a portable version
that works with unpatched versions of org-mode as far back as =8.2.10= (the version
bundled with =emacs-24.5=).
** Note on coderefs
Older versions of =org-mode= do not know what to do with coderefs.
The simplest solution is to hide them in comments as =;(ref:coderef)=
if you need them. See [[(clrin)]] and [[(oab)]] for examples in this file.
** How local variables appear in the file
# DO NOT EDIT THESE BLOCKS THEY ARE UPDATED AUTOMATICALLY
Here is what the prop line local variables at the start of the file looks like.
#+name: local-variables-prop-line-example
#+begin_src org :eval never
# -*- no-klobber-test: "I should still be here after it is all over!"; org-adapt-indentation: nil; org-edit-src-content-indentation: 0; orgstrap-cypher: sha256; orgstrap-block-checksum: 595964ff8394ab1ea6282a13e76b3f4d757f358a337b4cb4c52df0b2266c9fd3; -*-
#+end_src

# BE VERY CAREFUL WITH MANUAL EDITS
# If this block is being edited manually the automatic update will not work.
Here is what the =:noexport:= at the end of the file looks like.
#+name: local-variables-example
#+begin_src org :eval never

# Local Variables:
# orgstrap-local-variables-block-version: "0.1"
# eval: (when (not (fboundp 'org-src-coderef-regexp)) (defun org-src-coderef-regexp (fmt &optional label) (let ((fmt org-coderef-label-format)) (format "\\([:blank:]*\\(%s\\)[:blank:]*\\)$" (replace-regexp-in-string "%s" (if label (regexp-quote label) "\\([-a-zA-Z0-9_][-a-zA-Z0-9_ ]*\\)") (regexp-quote fmt) nil t)))))
# eval: (defun orgstrap--expand-body (info) "Expand references in INFO body if :noweb header is set." (let ((coderef (nth 6 info)) (expand (if (org-babel-noweb-p (nth 2 info) :eval) (org-babel-expand-noweb-references info) (nth 1 info)))) (if (not coderef) expand (replace-regexp-in-string (org-src-coderef-regexp coderef) "" expand nil nil 1))))
# eval: (defun orgstrap--confirm-eval (lang body) (not (and (member lang '("elisp" "emacs-lisp")) (let* ((body (orgstrap--expand-body (org-babel-get-src-block-info))) (body-normalized (let ((print-quoted nil)) (prin1-to-string (read (concat "(progn\n" body "\n)"))))) (content-checksum (intern (secure-hash orgstrap-cypher body-normalized)))) (eq orgstrap-block-checksum content-checksum)))))
# eval: (setq-local org-confirm-babel-evaluate #'orgstrap--confirm-eval)
# eval: (unwind-protect (save-excursion (org-babel-goto-named-src-block "orgstrap") (org-babel-execute-src-block)) (setq-local org-confirm-babel-evaluate t) (fmakunbound #'orgstrap--confirm-eval))
# End:
#+end_src
* Code
** =orgstrap= implementation
Functions to calculate =orgstrap-block-checksum= and set it as a file local variable.
Add the necessary local variables to the end of the file.
# [[info:elisp#File Local Variables][info:elisp#File Local Variables]] a useful reference
*** Expand
Testing =org-src-coderef-regexp= with =fboundp= in ref:orgstrap-expand-body
is needed due to changes in the behavior of =org-babel-get-src-block-info=
roughly around the =9.0= release.

The changes in behavior for =org-babel-get-src-block-info= are commits
orgit-rev:~/git/NOFORK/org-mode::88659208793dca18b7672428175e9a712af7b5ad and
orgit-rev:~/git/NOFORK/org-mode::9738da473277712804e0d004899388ad71c6b791. They
both occur before the introduction of =org-src-coderef-regexp= in
orgit-rev:~/git/NOFORK/org-mode::9f47b37231b3c45afcd604a191e346200bd76e98.
All of this happend before orgit-rev:~/git/NOFORK/org-mode::release_9.0. By
testing =org-src-coderef-regexp= with =fboundp= there are only a tiny number
of versions where there might be some inconsistent behavior, e.g.
orgit-rev:~/git/NOFORK/org-mode::release_8.3.6, but I that the probability
that anyone anywhere is running one of those versions is approximately zero.

#+name: orgstrap-expand-body
#+begin_src elisp :eval never
(when (not (fboundp 'org-src-coderef-regexp))
  (defun org-src-coderef-regexp (fmt &optional label)
    (let ((fmt org-coderef-label-format))
      (format "\\([:blank:]*\\(%s\\)[:blank:]*\\)$"
              (replace-regexp-in-string
               "%s"
               (if label
                   (regexp-quote label)
                 "\\([-a-zA-Z0-9_][-a-zA-Z0-9_ ]*\\)")
               (regexp-quote fmt)
               nil t)))))

(defun orgstrap--expand-body (info)
  "Expand references in INFO body if :noweb header is set."
  (let ((coderef (nth 6 info))
        (expand
         (if (org-babel-noweb-p (nth 2 info) :eval)
             (org-babel-expand-noweb-references info)
           (nth 1 info))))
    (if (not coderef)
        expand
      (replace-regexp-in-string
       (org-src-coderef-regexp coderef) "" expand nil nil 1))))
#+end_src
*** Edit
#+caption: edit helpers
#+name: orgstrap-edit-helper-defuns
#+begin_src emacs-lisp :results none :lexical yes :noweb yes
;;; edit helpers
(defvar orgstrap-orgstrap-block-name "orgstrap"
  "Set the default blockname to orgstrap by convention.
This makes it easier to search for orgstrap if someone encounters
an orgstrapped file and wants to know what is going on.")

(defvar orgstrap-default-cypher 'sha256
  "The default cypher passed to `secure-hash' when hashing blocks.")

(defcustom orgstrap-on-change-hook nil
  "Hook run via `before-save-hook' when command `orgstrap-mode' is enabled.
Only runs when the contents of the orgstrap block have changed."
  :type 'hook
  :group 'orgstrap)

;; edit utility functions
(defun orgstrap--current-buffer-cypher ()
  "Return the cypher used for the current buffer.
The value returned is `orgstrap-cypher' or if there is not buffer local cypher
then `orgstrap-default-cypher' is returned."
  (if (boundp 'orgstrap-cypher) orgstrap-cypher orgstrap-default-cypher))

<<orgstrap-expand-body>>

(defmacro orgstrap--with-block (blockname &rest macro-body)
  "Go to the source block named BLOCKNAME and execute MACRO-BODY.
The macro provides local bindings for four names:
`info', `params', `body-unexpanded', and `body'."
  (declare (indent defun))
  ;; consider accepting :lite or a keyword or something to pass
  ;; lite as an optional argument to `org-babel-get-src-block-info'
  ;; e.g. via (lite (equal (car macro-body) :lite)), given the
  ;; behavior when lite is not nil and the expected useage of this
  ;; macro I don't think we would ever want to pass a non nil lite
  `(save-excursion
     (let ((inhibit-message t)) ; inhibit-message only blocks from the message area not the log
       (org-babel-goto-named-src-block ,blockname))
     (unwind-protect
         (let* ((info (org-babel-get-src-block-info))
                (params (nth 2 info))
                (body-unexpanded (nth 1 info))
                ;; from `org-babel-check-confirm-evaluate'
                ;; and `org-babel-execute-src-block'
                (body (orgstrap--expand-body info)))
           ,@macro-body)
       (org-mark-ring-goto))))

;; edit user facing functions
(defun orgstrap-get-block-checksum (&optional cypher)
  "Calculate the `orgstrap-block-checksum' for the current buffer using CYPHER."
  (interactive)
  (orgstrap--with-block orgstrap-orgstrap-block-name
    (ignore params body-unexpanded)
    (let ((cypher (or cypher (orgstrap--current-buffer-cypher)))
          (body-normalized
           <<orgstrap-code-normalization>>))
      (secure-hash cypher body-normalized))))

(defun orgstrap-add-block-checksum (&optional cypher checksum)
  "Add `orgstrap-block-checksum' to file local variables of `current-buffer'.
The optional CYPHER argument should almost never be used,
instead change the value of `orgstrap-default-cypher' or manually
change the file property line variable.  CHECKSUM can be passed
directly if it has been calculated before and only needs to be set."
  (interactive)
  (let* ((cypher (or cypher (orgstrap--current-buffer-cypher)))
         (orgstrap-block-checksum (or checksum (orgstrap-get-block-checksum cypher))))
    (when orgstrap-block-checksum
      (save-excursion
        (add-file-local-variable-prop-line 'orgstrap-cypher cypher)
        (add-file-local-variable-prop-line 'orgstrap-block-checksum (intern orgstrap-block-checksum))))
    orgstrap-block-checksum))

(defun orgstrap--update-on-change ()
  "Run via the `before-save-hook' local variable.
Test if the checksum of the orgstrap block has changed,
if so update the `orgstrap-block-checksum' local variable
and then run `orgstrap-on-change-hook'."
  (let* ((elv (orgstrap--read-current-local-variables))
         (checksum-existing (assoc 'orgstrap-block-checksum elv))
         (checksum (orgstrap-get-block-checksum)))
    (unless (eq checksum-existing checksum)
      (remove-hook 'before-save-hook #'orgstrap--update-on-change t)
      ;; have to remove the hook because for some reason tangling from a buffer
      ;; counts as saving from that buffer?
      (save-excursion
        ;; using save-excusion here is a good for insurance against wierd hook issues
        ;; however it does not deal with the fact that updating `orgstrap-add-block-checksum'
        ;; adds an entry to the undo ring, which is bad
        ;;(undo-boundary)  ; undo-boundary doesn't quite work the way we want
        ;; related https://emacs.stackexchange.com/q/7558
        (orgstrap-add-block-checksum nil checksum)
        (run-hooks 'orgstrap-on-change-hook))
      (add-hook 'before-save-hook #'orgstrap--update-on-change 0 t))))

;;;###autoload
(define-minor-mode orgstrap-mode
  "Minor mode for working with orgstrapped files."
  nil "" nil

  (unless (eq major-mode 'org-mode)
    (setq orgstrap-mode nil)
    (user-error "`orgstrap-mode' only works with org-mode buffers"))

  (cond (orgstrap-mode
         (add-hook 'before-save-hook #'orgstrap--update-on-change 0 t))
        (t
         (remove-hook 'before-save-hook #'orgstrap--update-on-change))))
#+end_src
#+name: orgstrap-aux-safe-blocks
#+begin_src elisp
#+end_src
*** Init
A note on filter aka =cl-remove-if-not= in =orgstrap--add-file-local-variables= at [[(clrin)]].
| emacs version | require |
|---------------+---------|
| < 24          | 'cl     |
| < 25          | 'cl-lib |
| < 27          | 'seq    |
The most portable thing to do for now is =(require 'cl-lib)= since we
don't currently support anything below 23. Then use =cl-remove-if-not=.

#+caption: init helpers
#+name: orgstrap-init-helper-defuns
#+begin_src emacs-lisp :results none :lexical yes :noweb yes
;;; init helpers
(require 'cl-lib)

(defvar orgstrap-link-message "jump to the orgstrap block for this file"
  "Default message for file internal links.")

(defconst orgstrap--default-local-variables-block-version "0.1"
  "End of file local variables verion number.
Used to set visible version number in the
file local variables in `orgstrap--add-file-local-variables'")

(defconst orgstrap--local-variable-eval-commands-0.1
  '(
    <<orgstrap-file-local-variables-0.1>>))

(defconst orgstrap--local-variable-eval-commands-0.2
  '(
    <<orgstrap-file-local-variables-0.2>>))

(defun orgstrap--local-variable-eval-commands (&optional version)
  "Return the set of eval local variable commands for VERSION."
  (let ((version (or version orgstrap--default-local-variables-block-version)))
    (pcase version
      ("0.1" orgstrap--local-variable-eval-commands-0.1)
      ("0.2" orgstrap--local-variable-eval-commands-0.2))))

;; init utility functions

(defun orgstrap--new-heading-elisp-block (heading block-name &optional header-args noexport)
  "Create a new elisp block named BLOCK-NAME in a new heading titled HEADING.
The heading is inserted at the top of the current file.
HEADER-ARGS is an alist of symbols that are converted to strings.
If NOEXPORT is non-nil then the :noexport: tag is added to the heading."
  (save-excursion
    (goto-char (point-min))
    (outline-next-heading)  ;; alternately outline-next-heading
    (org-meta-return)
    (insert (format "%s%s\n" heading (if noexport " :noexport:" "")))
    ;;(org-edit-headline heading)
    ;;(when noexport (org-set-tags "noexport"))
    (move-end-of-line 1)
    (insert "\n#+name: " block-name "\n")
    (insert "#+begin_src elisp")
    (mapc (lambda (header-arg-value)
            (insert " :" (symbol-name (car header-arg-value))
                    " " (symbol-name (cdr header-arg-value))))
          header-args)
    (insert "\n#+end_src\n")))

(defun orgstrap--trap-hack-locals (command &rest args)
  "Advice for `hack-local-variables-filter' to do nothing except the following.
Set `orgstrap--local-variables' to the reversed list of read variables which
are the first argument in the lambda list ARGS.
COMMAND is unused since we don't actually want to hack the local variables,
just get their current values."
  (ignore command)
  (setq-local orgstrap--local-variables (reverse (car args)))
  nil)

(defun orgstrap--read-current-local-variables ()
  "Return the local variables for the current file without applying them."
  (interactive)
  ;; orgstrap--local-variables is a temporary local variable that is used to
  ;; capture the input to `hack-local-variables-filter' it is unset at the end
  ;; of this function so that it cannot accidentally be used when it might be stale
  (setq-local orgstrap--local-variables nil)
  (let ((enable-local-variables t))
    (advice-add #'hack-local-variables-filter :around #'orgstrap--trap-hack-locals)
    (unwind-protect
        (hack-local-variables nil)
      (advice-remove #'hack-local-variables-filter #'orgstrap--trap-hack-locals))
    (let ((local-variables orgstrap--local-variables))
      (makunbound 'orgstrap--local-variables)
      local-variables)))

(defun orgstrap--add-link-to-orgstrap-block (&optional link-message)
  "Add an `org-mode' link pointing to the orgstrap block for the current file.
The link is placed in comment on the second line of the file.  LINK-MESSAGE
can be used to override the default value set via `orgstrap-link-message'"
  (interactive)  ; TODO prompt for message with C-u ?
  (goto-char (point-min))
  (next-logical-line)  ; use logical-line to avoid issues with visual line mode
  (let ((link-message (or link-message orgstrap-link-message)))
    (unless (save-excursion (re-search-forward
                             (format "^# \\[\\[%s\\]\\[.+\\]\\]$"
                                     orgstrap-orgstrap-block-name)
                             nil t))
      (insert (format "# [[%s][%s]]\n"
                      orgstrap-orgstrap-block-name
                      (or link-message orgstrap-link-message))))))

(defun orgstrap--add-orgstrap-block ()
  "Add a new elisp source block with #+name: orgstrap to the current buffer.
If a block with that name already exists raise an error."
  (interactive)
  (let ((all-block-names (org-babel-src-block-names)))
    (if (member orgstrap-orgstrap-block-name all-block-names)
        (message "orgstrap block already exists not adding!")
      (orgstrap--new-heading-elisp-block "Bootstrap"
                                         orgstrap-orgstrap-block-name
                                         '((results . none)
                                           (lexical . yes))
                                         t)
      (orgstrap--with-block orgstrap-orgstrap-block-name
        (ignore params body-unexpanded body)
        ;;(error "TODO insert some minimal message or something")
        nil))))

(defun orgstrap--add-file-local-variables (&optional version)
  "Add the file local variables needed to make orgstrap work.
VERSION is currently used to control whether 0.1 or 0.2 is used.
Version should be orthognal to whether the block supports noweb
and old versions of `org-mode' and the selection for noweb should
be detected automatically, similarly we could automatically include
a version test and fail if the version is unsupported."
  ;; switching comments probably wont work ? we can try
  ;; Use a prefix argument (i.e. C-u) to add file local variables comments instead of in a :noexport:
  (interactive)
  (let* ((version (or version orgstrap--default-local-variables-block-version))
         (lv-commands (orgstrap--local-variable-eval-commands version))
         (elv (orgstrap--read-current-local-variables))
         (commands-existing (mapcar #'cdr (cl-remove-if-not (lambda (l) (eq (car l) 'eval)) elv)))) ;(ref:clrin)
    ;; good enough to start
    (cond ((equal commands-existing lv-commands) nil)
          ((not commands-existing)
           (let ((print-escape-newlines t))  ; needed to preserve the escaped newlines
             (add-file-local-variable 'orgstrap-local-variables-block-version
                                      version)
             (mapcar (lambda (sexp) (add-file-local-variable 'eval sexp))
                     lv-commands)))
          ;; we could try to do something fancy here, but it is much simpler
          ;; to just alert the user and have them fix it
          (t (error "Existing eval commands that do not match the commands to be installed have been detected.  Please remove those commands and run `orgsrap-add-file-local-variables' again or manually add the orgstrap file local variables.  The existing commands are as follows.\n%s" commands-existing)))))

;; init user facing functions
;;;###autoload
(defun orgstrap-init ()
  "Initialize orgstrap in the current buffer and enable command `orgstrap-mode'."
  (interactive)
  (when (not (eq major-mode 'org-mode))
    (error "Cannot orgstrap, buffer not in `org-mode' it is in %s!" major-mode))
  ;; TODO option for no link?
  ;; TODO option for local variables in comments vs noexport
  (save-excursion
    (orgstrap--add-orgstrap-block)
    (orgstrap-add-block-checksum)
    (orgstrap--add-link-to-orgstrap-block)
    ;; FIXME sometimes local variables don't populate due to an out of range error
    (orgstrap--add-file-local-variables)
    (orgstrap-mode)))
#+end_src
*** TODO Install
#+caption: install helpers
#+name: orgstrap-install-helper-defuns
#+begin_src emacs-lisp :results none
;; install helpers
(defvar orgstrap-helper-block-name "orgstrap-helper"
  "Name for the embedded helper block.")
(defun orgstrap-install-orgstrap ()
  "Install orgstrap.el directly from this file."
  (error "TODO"))
(defun orgstrap--add-install-block ()
  "Install this block in an `org-mode' file." ; really? or was this meant to do something else?
  (error "TODO"))
(defun orgstrap--add-helper-block (&optional block-name)
  "Embed orgstrap helpers block named BLOCK-NAME in the current buffer.
This makes it so that anyone encountering the file in the future has all
the tools they need to make changes without requiring any additional steps."
  ;; TODO minimal vs maximal, edit files vs propagate orgstrap
  ;; go to start of file
  ;; look for first heading
  ;; insert before first heading (so it is visible and users can reorder as needed)
  ;; insert source block
  (let ((block-name (or block-name orgstrap-helper-block-name)))

    (orgstrap--new-heading-elisp-block "orgstrap-helpers"
                                       block-name
                                       '((results . none)
                                         (lexical . yes))
                                       t)

    (orgstrap--with-block block-name
      (ignore params body-unexpanded body)
      (error "TODO"))))

;;(defvar orgstrap--helpers nil)
;;(setq orgstrap--helpers nil)
;;; TODO
;; options are link to docs or
;; embed (defun orgstrap-install-helpers () (interactive) (use-package orgstrap)) or similar or
;; embed all of this block or orgstrap.el in a block in * orgstrap helpers :noexport:
#+end_src
*** Extras
#+caption: extra helpers
#+name: orgstrap-extra-helper-defuns
#+begin_src elisp :noweb yes
;;; extra helpers
(defun orgstrap-update-src-block (name content)
  "Set the content of source block named NAME to string CONTENT.
XXX NOTE THAT THIS CANNOT BE USED WITH EXAMPLE BLOCKS."
  ;; FIXME this seems to fail if the existing block is empty?
  ;; or at least adding file local variables fails?
  (let ((block (org-babel-find-named-block name)))
    (if block
        (save-excursion
          (org-babel-goto-named-src-block name)
          (org-babel-update-block-body content))
      (error "No block with name %s" name))))

(defun orgstrap-get-src-block-checksum (&optional cypher)
  "Calculate of the checksum of the current source block using CYPHER."
  (interactive)
  (let* ((info (org-babel-get-src-block-info))
         (params (nth 2 info))
         (body-unexpanded (nth 1 info))
         (body (orgstrap--expand-body info))
         (body-normalized
          <<orgstrap-code-normalization>>)
         (cypher (or cypher (orgstrap--current-buffer-cypher))))
    (ignore params body-unexpanded)
    (secure-hash cypher body-normalized)))

(defun orgstrap-get-named-src-block-checksum (name &optional cypher)
  "Calculate the checksum of the first sourc block named NAME using CYPHER."
  (interactive)
  (orgstrap--with-block name
    (ignore params body-unexpanded)
    (let ((cypher (or cypher (orgstrap--current-buffer-cypher)))
          (body-normalized
           <<orgstrap-code-normalization>>))
      (secure-hash cypher body-normalized))))

(defun orgstrap-run-additional-blocks (&rest name-checksum) ;(ref:oab)
  "Securely run additional blocks in languages other than elisp.
Do this by providing the name of the block and the checksum to be embedded
in the orgstrap block as NAME-CHECKSUM pairs."
  (ignore name-checksum)
  (error "TODO"))
#+end_src

Ideally we want to call [[(oab)][orgstrap-run-additional-blocks]] as
=(orgstrap-run-additional-blocks "additional-block-name" "checksum-value-hash-thing" "ab2" "cs2")=
It probably makes sense to house this in its own orgstrap-aux block or something.
I want to keep the file local variables as minimal as possible, so having another
aux block that could be automatically updated with the names and hashes of additional
blocks would be nice ... probably via something like =orgstrap-add-additional-block=
but it will not go in the local variables because we want there to be some hope of
orgstrap being portable to other platforms outside of emacs at some point in the
very distant future, so keeping the machinery outside of the org file itself as
minimal as possible is critical.
** orgstrap.el :noexport:
# XXX TODO it would be a super cool feature if xref could resolve to elisp source
# blocks in org-mode files, because then half the need for the .el file would go away
#+caption: Retangle this if something changes.
#+name: orgstrap.el
#+header: :exports none
#+begin_src elisp :noweb yes :eval never :tangle ./orgstrap.el
;;; orgstrap.el --- Bootstrap an org-mode file using file local variables -*- lexical-binding: t -*-

;; Author: Tom Gillespie
;; URL: https://github.com/tgbugs/orgstrap
;; Keywords: lisp org org-mode bootstrap
;; Version: 1.0
;; URL: https://github.com/purcell/flycheck-package
;; Package-Requires: ((emacs "24.4"))

;;;; License and Commentary

;; License:
;; GPLv3

;;; Commentary:

;; The license for the orgstrap.el code reflects the fact that
;; `orgstrap-get-block-checksum' reuses code from
;; `org-babel-check-confirm-evaluate' which is
;; (at the time of writing) in ob-core.el and licensed
;; as part of Emacs.

;; Code in an orgstrap block is usually meant to be executed directly by its
;; containing org file.  However, if the code is something that will be reused
;; over time outside the defining org file then it may be better to tangle and
;; load the file so that it is easier to debug/xref functions.  This code in
;; particular is tangled for inclusion in one of the *elpas so as to protect
;; the orgstrap namespace.

;;; Code:

<<orgstrap-edit-helper-defuns>>

<<orgstrap-init-helper-defuns>>

<<orgstrap-install-helper-defuns>>

<<orgstrap-extra-helper-defuns>>

(provide 'orgstrap)

;;; orgstrap.el ends here
#+end_src
** Testing :noexport:
#+name: test-0.1
#+begin_src bash :var THIS_FILE=(buffer-file-name) :results none
emacs-24 -q $THIS_FILE
emacs-25 -q $THIS_FILE
emacs-26 -q $THIS_FILE
emacs-27 -q $THIS_FILE
emacs-28-vcs -q $THIS_FILE
#+end_src

#+name: test-0.2
#+begin_src bash :var THIS_FILE=(buffer-file-name) :results none
emacs-24 -q orgstrap-minimal.org
emacs-25 -q orgstrap-minimal.org
emacs-26 -q orgstrap-minimal.org
emacs-27 -q orgstrap-minimal.org
emacs-28-vcs -q orgstrap-minimal.org
#+end_src
* Best practices
** Use the system package manager.
There is a big difference between using a script to install a program directly
from the internet and using a script to ask the host system to install a program.

Even if you audit a random script from the internet it is unlikely that you will
be able to do due diligence. On the other hand, if you ask your system package
manager to install something for you, there is a much better chance that it has
at least been somewhat audited, and there is usually an existing process for
getting a package into the system which helps to mitigate certain types of attacks.

To give a military example it is the difference between inspecting and accepting a
package from a random person because they say you asked for it yesterday (maybe you
did!) versus only every allowing packages to come through procurement. You are much
less likely to get a bomb or a packaged rigged to exfil data if you go through
procurement because there is an established process for how to do things and that
process enshrines generations experience about how to not get blown up by the pizza guy.

So, if you are writing instructions that require a certain tool, it is better to tell
whoever is following them to ask procurement to get the tool for them than to tell them
to going out to the hardware store and get it themselves, or worse, give them the address
of a random tool delivery man who happens to be a good buddy of yours. Even if everyone
involved is trustworthy those kinds of relationships are much easier for some third party
to compromise and use for their own purposes.

The obvious corollary when you are the user rather than the author, is that if you
encounter instructions that ask you to directly install software from a random place
you should be suspicious, even, perhaps especially, if that random place is housed
within a larger reputable site. If you're not in a hurry, ask for the software to be
packaged, or package it yourself so that it can go through the process.
* Future work
:PROPERTIES:
:CUSTOM_ID: future-work
:END:
** Security considerations
=orgstrap= currently does not check all the headers or vars properties that materialized
onto a source block we probably need to do this. For the time being users need to check
for any hidden header properties that might be attached if the source block is buried
within a tree somewhere.
** Known issues
*** Starting orgstrap in =*scratch*= and saving to file loses =before-save-hook=
This is a general issue any time a file local variable is set on a buffer that is
not backed by a file. In this case the fix is to disable and then enable =orgstrap-mode=,
however it would be nice if we could detect those cases automatically.
** Run once
In principle the simplest way to do this is to use the =:cache yes= header on a block.
However, unless the state is persisted into a users =init.el= file or equivalent, then
the file would need a way to know that it had not been run when opened again in a new
emacs session. Similar issue with opening the same file in multiple emacs sessions at
the same time. The block simply will not run again if the cached result is present.

Therefore, since =:cache yes= by itself is a dead end for ensuring that functionality
is always available any time a file is loaded there are a couple of options.
1. Persist to =init.el=. This is evil.
2. Request to tangle and install as package.
   A variant of this is simply to use packages.el to install
   the desired functionality in a persistent way in combination
   with accept klobbering.
3. Figure out how to transparently wrap an elisp block in =unless=.
4. Advise =defun= (say what!?)?  @@comment: TERROR@@
5. Figure out how to un-cache a block when emacs exits.
   This will fail in nasty, unpredictable, and hard to debug ways.
6. Set =:cache (if (boundp 'orgstrap-already-run) "yes" "no")=.
   This ALMOST works. If =:cache no= embedded the sha1 sum then
   we would be golden. *This seems like the best bet.*
7. Accept klobbering.
8. Advise org-babel-eval to run with org-babel-sha1-sum even when cache is not set to yes
** Tangle once
When bootstrapping a new system there are many times when want to create a
file only if it does not already exist. The =:tangle= header does not support
this use case, but we can implement it anyway using the example below.
#+name: tangle-once-example
#+begin_src org
,#+name: orgstrap
,#+begin_src elisp
(defun tangle-once (path) (if (file-exists-p path) "no" path))
,#+end_src

,#+begin_src bash :tangle (tangle-once "./path-to-tangle")
echo lol
,#+end_src
# I think I've seen this before but you apparently can't have ,#+end_src on the line before #+end_src ... fun bug
#+end_src
** Multiple blocks
There must be only a single one of those blocks so that the rest of
the blocks can safely use the functions defined in the orgstrap block.

A single elisp block is sufficient to enable nearly all use cases involving
tangling source blocks to file without having to fight the prompts. However,
it is very much not sufficient for any use cases that involve other languages.
This is particularly an issue for org files that want to bootstrap whole systems.

The simplest solution to me seems to be to add a second prompt variable which is
an alist of source block checksums and names[fn::the names are not technically required
but are for human readability]. As soon as the =orgstrap= block is run
=orgstrap--confirm-eval= is no longer needed and can be replace with a function
that validates the other blocks from the prompt variable.

This seems like a tractable approach, but also over complicated because it is surely
easier in a case like this where blocks are very unlikely to be reused across org files
to simply =(setq-local org-confirm-babel-evaluate nil)= and tell people to audit the
whole file. The alternative in that case might be to hash all the source blocks and
validate all of them at once at the start of the orgstrap block. This might need some
additional machinery, not entirely sure, maybe just have =orgstrap-all-blocks-checksum=
that can be used in cases like that. The advantage here is that the core of the process
can be verified once and then the documentation around it can change and grow as needed.
** Remove defun docstrings from hashing
One additional source of noise in addition to comments are defun and
defmacro docstrings. These should be dropped from the tree if they are
present.
** Deterministic semantics preserving reordering
Reorder the expressions used in the orgstrap block alphabetically (or something like that)
according to a deterministic rule, but not in a way that changes program semantics.
For example a function definition cannot be moved after a top level invocation of that
function.
1. defuns with different names can be reordered
2. defuns with the same name can be reordered as a block but cannot
   internally be reordered because the order of shadowing matters
3. While it might be nice to completely erase the names of functions as well
   as internal variable names, this would make it trivial to shadow existing
   function names in ways that are malicious. The exact names matter, so we
   have to preserve them. Also the cost of not being able to tell that
   =(lambda (a) (+ a a))= and =(lambda (b) (+ b b))= are the same seems fairly
   small.
4. One potential approach is to lift all defuns to the top, and then function calls
   or whatever the more generic procedure invocation means. The simple local rule
   is that all definitions must occur before usage except in the case where there is
   a shadowing even that happens after a first invocation. This is annoying, but
   if a call to a function happens before that function is defined we have to assume
   that the call is calling some other function and those statements cannot be reordered.
   So the ordering is calls to functions with names matching any later defuns or
   any later assignment. Then defuns and assignments, finally procedure invocations
   which might also include assignments. I get the sense that this is covered under
   some part of compiler theory but can't quite put my finger on it.
** DONE Auto update block checksum on save
Before save hook and/or before commit hook to automatically update the block checksum.
** determine whether to use 0.1 vs 0.2 based on the :noweb header
The smaller 0.2 block is portable without noweb, so as long as the noweb header
is not set on the block (or really, as long as there are no references) then it
is entirely possible to use the more compact version.
** Smart update/upgrade using the version specifier
At the moment I'm making changes too quickly, but it would be nice to be able
to automatically swap out sets of known =eval:= local variables when we can
identify them.
** Figure out how to demo loading the packages used in this file
#+begin_src elisp
(use-package org-ref)
#+end_src
** TODO resolve the issue with tabs in < 26                        :noexport:
** TODO command to checksum the file local variables               :noexport:
** TODO use orgstrap to automatically keep example blocks in sync  :noexport:
** TODO melpa                                                      :noexport:
** TODO ruby org so that github can render footnotes correctly     :noexport:
[[file:~/git/NOFORK/org-ruby]]
* Background, file local variables, and checksums
As mentioned above, the primary use case for =orgstrap= was that I was sick of having
to work around the limitation that I had to do one of four things. I either one, had
to remember to eval the source block containing defuns used later before I could
eval other source blocks that used those functions in headers, or two, had to put those
functions in =init.el=, destroying the ability to use org files as standalone self describing
portable and reusable computational artifacts, three, had to copy and paste verbose
elisp bits around to achieve what I wanted, or four, had to double tangle a file so that
the results of the first tangle could be loaded before calling the second tangle so that
the functionality would be available (this also produces the situation described in three).
Furthermore, it is hard for humans to follow all the steps needed to get everything
working -- even when 'everything' is just invoking =C-c C-c= on a single source block
I still forget. This can lead to _bad things_ if some of those source blocks were
interdependent, or proceeded with a nil, etc.

File local variables to the rescue!
I'm slightly embarrassed to say how long it took me to arrive at the current solution.
I had known for quite a while that file local variables are a pathway to +abilities that+
the evils of arbitrary code execution, but it didn't click that all I was looking for was
the ability to just run some arbitrary elisp code every time a particular file was loaded,
which of course is exactly what file local variables are for.

The only question then was how to avoid the very real dangers of enabling arbitrary code
execution of plain text. Actually it was more along the lines of "How can I keep org-babel
happy without also pwning myself?" Fortunately = org-confirm-babel-evaluate = can be customized
to be a function that accepts the body of the code to be evaluated. Therefore we can do the
following.

When creating a file.
1. *Hash the block to be run before distributing the file.*
   Make sure to test if there are any changes to the header.
   For example I have a bad habit of accidentally setting
   =:noweb no-export= incorrectly without the dash and that will
   prevent the checksum from updating if a nowebbed block changes.
2. *Embed the checksum in the file local variable property line.*
   The property line is highly visible as the first line of the
   file. This makes it easy for users to verify that the embedded
   checksum matches a known independent checksum (running step 2).
   Thus if the embedded checksum does not match a known checksum
   the user will notice, and if the code to be executed does not
   match the embedded checksum then the user will at least be
   prompted by org-mode to run the block even in the case where
   they accepted the file local variables. Emacs also prompts for
   verification of the property line value which is another
   opportunity for the user to check.
3. *Publish the checksum independent of the file itself.*
   It is trivial for someone to change the contents of the orgstrap block
   and rerun =M-x= =orgstrap-add-block-checksum=. Therefore known checksums
   need to be published independent of the files themselves.

When running a file.
1. *Audit, accept, and store permanently the eval file local variables.*
   Storing audited variables permanently is critical for improving signal to noise
   so that unexpected mismatches retain their salience and can elicit the correct
   response (i.e., suspicion).
   # XXX there may be an issue here if the property line tags along with the rest
   # because we want to be able to mark the exact variables used in this file
   # as safe and if they are couple to a random hash that is bad
2. *Audit the orgstrap block*
   I assume most people are not going to do this. However, one of the advantages
   of the current approach is that the same orgstrap blocks can be reused across
   multiple files which reduces the audit load such that one only needs to review
   unique orgstrap blocks, not all files. [fn::NOTE there are certain patterns inside
   blocks that are NOT safe to accept because they introduce a level of indirection
   that orgstrap cannot verify. Examples of these kinds of dangerous blocks are ones
   that make any reference to other blocks in the file via some means other than noweb.
   This isn't really surprising, and for use cases where =org-babel-execute-src-block=
   is called multiple times on different blocks, the default execution protection will
   work. In addition, any blocks which want to run automatically without prompting should
   use the =orgstrap--confirm-eval= function (see [[file:::#future-work][Future work]]).]
3. *Verify that the embedded checksum matches the independent checksum.*
   A known embedded checksum matching the content checksum only means that the content
   matches the content observed by the provider of the independent checksum
   (assuming no hash collisions).
4. *Observe whether org-mode complains that the orgstrap block has changed.*
* Local Variables Footer :noexport:

# Local Variables:
# orgstrap-local-variables-block-version: "0.1"
# eval: (when (not (fboundp 'org-src-coderef-regexp)) (defun org-src-coderef-regexp (fmt &optional label) (let ((fmt org-coderef-label-format)) (format "\\([:blank:]*\\(%s\\)[:blank:]*\\)$" (replace-regexp-in-string "%s" (if label (regexp-quote label) "\\([-a-zA-Z0-9_][-a-zA-Z0-9_ ]*\\)") (regexp-quote fmt) nil t)))))
# eval: (defun orgstrap--expand-body (info) "expand noweb references if noweb is set" (let ((coderef (nth 6 info)) (expand (if (org-babel-noweb-p (nth 2 info) :eval) (org-babel-expand-noweb-references info) (nth 1 info)))) (if (not coderef) expand (replace-regexp-in-string (org-src-coderef-regexp coderef) "" expand nil nil 1))))
# eval: (defun orgstrap--confirm-eval (lang body) (not (and (member lang '("elisp" "emacs-lisp")) (let* ((body (orgstrap--expand-body (org-babel-get-src-block-info))) (body-normalized (let ((print-quoted nil)) (prin1-to-string (read (concat "(progn\n" body "\n)"))))) (content-checksum (intern (secure-hash orgstrap-cypher body-normalized)))) (eq orgstrap-block-checksum content-checksum)))))
# eval: (setq-local org-confirm-babel-evaluate #'orgstrap--confirm-eval)
# eval: (unwind-protect (save-excursion (org-babel-goto-named-src-block "orgstrap") (org-babel-execute-src-block)) (setq-local org-confirm-babel-evaluate t) (fmakunbound #'orgstrap--confirm-eval))
# End:
